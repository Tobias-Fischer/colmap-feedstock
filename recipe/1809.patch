diff --git a/src/mvs/cuda_array_wrapper.h b/src/mvs/cuda_array_wrapper.h
deleted file mode 100644
index e4e48b0e8..000000000
--- a/src/mvs/cuda_array_wrapper.h
+++ /dev/null
@@ -1,171 +0,0 @@
-// Copyright (c) 2023, ETH Zurich and UNC Chapel Hill.
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are met:
-//
-//     * Redistributions of source code must retain the above copyright
-//       notice, this list of conditions and the following disclaimer.
-//
-//     * Redistributions in binary form must reproduce the above copyright
-//       notice, this list of conditions and the following disclaimer in the
-//       documentation and/or other materials provided with the distribution.
-//
-//     * Neither the name of ETH Zurich and UNC Chapel Hill nor the names of
-//       its contributors may be used to endorse or promote products derived
-//       from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
-// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-// POSSIBILITY OF SUCH DAMAGE.
-//
-// Author: Johannes L. Schoenberger (jsch-at-demuc-dot-de)
-
-#ifndef COLMAP_SRC_MVS_CUDA_ARRAY_WRAPPER_H_
-#define COLMAP_SRC_MVS_CUDA_ARRAY_WRAPPER_H_
-
-#include <memory>
-
-#include <cuda_runtime.h>
-
-#include "mvs/gpu_mat.h"
-#include "util/cudacc.h"
-
-namespace colmap {
-namespace mvs {
-
-template <typename T>
-class CudaArrayWrapper {
- public:
-  CudaArrayWrapper(const size_t width, const size_t height, const size_t depth);
-  ~CudaArrayWrapper();
-
-  const cudaArray* GetPtr() const;
-  cudaArray* GetPtr();
-
-  size_t GetWidth() const;
-  size_t GetHeight() const;
-  size_t GetDepth() const;
-
-  void CopyToDevice(const T* data);
-  void CopyToHost(const T* data);
-  void CopyFromGpuMat(const GpuMat<T>& array);
-
- private:
-  // Define class as non-copyable and non-movable.
-  CudaArrayWrapper(CudaArrayWrapper const&) = delete;
-  void operator=(CudaArrayWrapper const& obj) = delete;
-  CudaArrayWrapper(CudaArrayWrapper&&) = delete;
-
-  void Allocate();
-  void Deallocate();
-
-  cudaArray* array_;
-
-  size_t width_;
-  size_t height_;
-  size_t depth_;
-};
-
-////////////////////////////////////////////////////////////////////////////////
-// Implementation
-////////////////////////////////////////////////////////////////////////////////
-
-template <typename T>
-CudaArrayWrapper<T>::CudaArrayWrapper(const size_t width, const size_t height,
-                                      const size_t depth)
-    : width_(width), height_(height), depth_(depth), array_(nullptr) {}
-
-template <typename T>
-CudaArrayWrapper<T>::~CudaArrayWrapper() {
-  Deallocate();
-}
-
-template <typename T>
-const cudaArray* CudaArrayWrapper<T>::GetPtr() const {
-  return array_;
-}
-
-template <typename T>
-cudaArray* CudaArrayWrapper<T>::GetPtr() {
-  return array_;
-}
-
-template <typename T>
-size_t CudaArrayWrapper<T>::GetWidth() const {
-  return width_;
-}
-
-template <typename T>
-size_t CudaArrayWrapper<T>::GetHeight() const {
-  return height_;
-}
-
-template <typename T>
-size_t CudaArrayWrapper<T>::GetDepth() const {
-  return depth_;
-}
-
-template <typename T>
-void CudaArrayWrapper<T>::CopyToDevice(const T* data) {
-  cudaMemcpy3DParms params = {0};
-  Allocate();
-  params.extent = make_cudaExtent(width_, height_, depth_);
-  params.kind = cudaMemcpyHostToDevice;
-  params.dstArray = array_;
-  params.srcPtr =
-      make_cudaPitchedPtr((void*)data, width_ * sizeof(T), width_, height_);
-  CUDA_SAFE_CALL(cudaMemcpy3D(&params));
-}
-
-template <typename T>
-void CudaArrayWrapper<T>::CopyToHost(const T* data) {
-  cudaMemcpy3DParms params = {0};
-  params.extent = make_cudaExtent(width_, height_, depth_);
-  params.kind = cudaMemcpyDeviceToHost;
-  params.dstPtr =
-      make_cudaPitchedPtr((void*)data, width_ * sizeof(T), width_, height_);
-  params.srcArray = array_;
-  CUDA_SAFE_CALL(cudaMemcpy3D(&params));
-}
-
-template <typename T>
-void CudaArrayWrapper<T>::CopyFromGpuMat(const GpuMat<T>& array) {
-  Allocate();
-  cudaMemcpy3DParms parameters = {0};
-  parameters.extent = make_cudaExtent(width_, height_, depth_);
-  parameters.kind = cudaMemcpyDeviceToDevice;
-  parameters.dstArray = array_;
-  parameters.srcPtr = make_cudaPitchedPtr((void*)array.GetPtr(),
-                                          array.GetPitch(), width_, height_);
-  CUDA_SAFE_CALL(cudaMemcpy3D(&parameters));
-}
-
-template <typename T>
-void CudaArrayWrapper<T>::Allocate() {
-  Deallocate();
-  struct cudaExtent extent = make_cudaExtent(width_, height_, depth_);
-  cudaChannelFormatDesc fmt = cudaCreateChannelDesc<T>();
-  CUDA_SAFE_CALL(cudaMalloc3DArray(&array_, &fmt, extent, cudaArrayLayered));
-}
-
-template <typename T>
-void CudaArrayWrapper<T>::Deallocate() {
-  if (array_ != nullptr) {
-    CUDA_SAFE_CALL(cudaFreeArray(array_));
-    array_ = nullptr;
-  }
-}
-
-}  // namespace mvs
-}  // namespace colmap
-
-#endif  // COLMAP_SRC_MVS_CUDA_ARRAY_WRAPPER_H_
diff --git a/src/mvs/cuda_texture.h b/src/mvs/cuda_texture.h
new file mode 100644
index 000000000..3dcd8d171
--- /dev/null
+++ b/src/mvs/cuda_texture.h
@@ -0,0 +1,180 @@
+// Copyright (c) 2023, ETH Zurich and UNC Chapel Hill.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//
+//     * Redistributions in binary form must reproduce the above copyright
+//       notice, this list of conditions and the following disclaimer in the
+//       documentation and/or other materials provided with the distribution.
+//
+//     * Neither the name of ETH Zurich and UNC Chapel Hill nor the names of
+//       its contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+//
+// Author: Johannes L. Schoenberger (jsch-at-demuc-dot-de)
+
+#ifndef COLMAP_SRC_MVS_CUDA_TEXTURE_H_
+#define COLMAP_SRC_MVS_CUDA_TEXTURE_H_
+
+#include <memory>
+
+#include <cuda_runtime.h>
+
+#include "mvs/gpu_mat.h"
+#include "util/cudacc.h"
+#include "util/logging.h"
+
+namespace colmap {
+namespace mvs {
+
+template <typename T>
+class CudaArrayLayeredTexture {
+ public:
+  static std::unique_ptr<CudaArrayLayeredTexture<T>> FromGpuMat(
+      const cudaTextureDesc& texture_desc, const GpuMat<T>& mat);
+  static std::unique_ptr<CudaArrayLayeredTexture<T>> FromHostArray(
+      const cudaTextureDesc& texture_desc, const size_t width,
+      const size_t height, const size_t depth, const T* data);
+
+  cudaTextureObject_t GetObj() const;
+
+  size_t GetWidth() const;
+  size_t GetHeight() const;
+  size_t GetDepth() const;
+
+  CudaArrayLayeredTexture(const cudaTextureDesc& texture_desc,
+                          const size_t width, const size_t height,
+                          const size_t depth);
+  ~CudaArrayLayeredTexture();
+
+ private:
+  // Define class as non-copyable and non-movable.
+  CudaArrayLayeredTexture(CudaArrayLayeredTexture const&) = delete;
+  void operator=(CudaArrayLayeredTexture const& obj) = delete;
+  CudaArrayLayeredTexture(CudaArrayLayeredTexture&&) = delete;
+
+  const size_t width_;
+  const size_t height_;
+  const size_t depth_;
+
+  cudaArray_t array_;
+  const cudaTextureDesc texture_desc_;
+  cudaResourceDesc resource_desc_;
+  cudaTextureObject_t texture_;
+};
+
+////////////////////////////////////////////////////////////////////////////////
+// Implementation
+////////////////////////////////////////////////////////////////////////////////
+
+template <typename T>
+std::unique_ptr<CudaArrayLayeredTexture<T>>
+CudaArrayLayeredTexture<T>::FromGpuMat(const cudaTextureDesc& texture_desc,
+                                       const GpuMat<T>& mat) {
+  auto array = std::make_unique<CudaArrayLayeredTexture<T>>(
+      texture_desc, mat.GetWidth(), mat.GetHeight(), mat.GetDepth());
+
+  cudaMemcpy3DParms params;
+  memset(&params, 0, sizeof(params));
+  params.extent =
+      make_cudaExtent(mat.GetWidth(), mat.GetHeight(), mat.GetDepth());
+  params.kind = cudaMemcpyDeviceToDevice;
+  params.srcPtr = make_cudaPitchedPtr((void*)mat.GetPtr(), mat.GetPitch(),
+                                      mat.GetWidth(), mat.GetHeight());
+  params.dstArray = array->array_;
+  CUDA_SAFE_CALL(cudaMemcpy3D(&params));
+
+  return array;
+}
+
+template <typename T>
+std::unique_ptr<CudaArrayLayeredTexture<T>>
+CudaArrayLayeredTexture<T>::FromHostArray(const cudaTextureDesc& texture_desc,
+                                          const size_t width,
+                                          const size_t height,
+                                          const size_t depth, const T* data) {
+  auto array = std::make_unique<CudaArrayLayeredTexture<T>>(texture_desc, width,
+                                                            height, depth);
+
+  cudaMemcpy3DParms params;
+  memset(&params, 0, sizeof(params));
+  params.extent = make_cudaExtent(width, height, depth);
+  params.kind = cudaMemcpyHostToDevice;
+  params.srcPtr =
+      make_cudaPitchedPtr((void*)data, width * sizeof(T), width, height);
+  params.dstArray = array->array_;
+  CUDA_SAFE_CALL(cudaMemcpy3D(&params));
+
+  return array;
+}
+
+template <typename T>
+CudaArrayLayeredTexture<T>::CudaArrayLayeredTexture(
+    const cudaTextureDesc& texture_desc, const size_t width,
+    const size_t height, const size_t depth)
+    : texture_desc_(texture_desc),
+      width_(width),
+      height_(height),
+      depth_(depth) {
+  CHECK_GT(width_, 0);
+  CHECK_GT(height_, 0);
+  CHECK_GT(depth_, 0);
+
+  cudaExtent extent = make_cudaExtent(width_, height_, depth_);
+  cudaChannelFormatDesc fmt = cudaCreateChannelDesc<T>();
+  CUDA_SAFE_CALL(cudaMalloc3DArray(&array_, &fmt, extent, cudaArrayLayered));
+
+  memset(&resource_desc_, 0, sizeof(resource_desc_));
+  resource_desc_.resType = cudaResourceTypeArray;
+  resource_desc_.res.array.array = array_;
+
+  CUDA_SAFE_CALL(cudaCreateTextureObject(&texture_, &resource_desc_,
+                                         &texture_desc_, nullptr));
+}
+
+template <typename T>
+CudaArrayLayeredTexture<T>::~CudaArrayLayeredTexture() {
+  CUDA_SAFE_CALL(cudaFreeArray(array_));
+  CUDA_SAFE_CALL(cudaDestroyTextureObject(texture_));
+}
+
+template <typename T>
+cudaTextureObject_t CudaArrayLayeredTexture<T>::GetObj() const {
+  return texture_;
+}
+
+template <typename T>
+size_t CudaArrayLayeredTexture<T>::GetWidth() const {
+  return width_;
+}
+
+template <typename T>
+size_t CudaArrayLayeredTexture<T>::GetHeight() const {
+  return height_;
+}
+
+template <typename T>
+size_t CudaArrayLayeredTexture<T>::GetDepth() const {
+  return depth_;
+}
+
+}  // namespace mvs
+}  // namespace colmap
+
+#endif  // COLMAP_SRC_MVS_CUDA_TEXTURE_H_
diff --git a/src/mvs/gpu_mat_ref_image.cu b/src/mvs/gpu_mat_ref_image.cu
index c40a10bc3..1e3cc9d5e 100644
--- a/src/mvs/gpu_mat_ref_image.cu
+++ b/src/mvs/gpu_mat_ref_image.cu
@@ -39,9 +39,8 @@ namespace colmap {
 namespace mvs {
 namespace {
 
-texture<uint8_t, cudaTextureType2D, cudaReadModeNormalizedFloat> image_texture;
-
-__global__ void FilterKernel(GpuMat<uint8_t> image, GpuMat<float> sum_image,
+__global__ void FilterKernel(const cudaTextureObject_t image_texture,
+                             GpuMat<uint8_t> image, GpuMat<float> sum_image,
                              GpuMat<float> squared_sum_image,
                              const int window_radius, const int window_step,
                              const float sigma_spatial,
@@ -54,7 +53,7 @@ __global__ void FilterKernel(GpuMat<uint8_t> image, GpuMat<float> sum_image,
 
   BilateralWeightComputer bilateral_weight_computer(sigma_spatial, sigma_color);
 
-  const float center_color = tex2D(image_texture, col, row);
+  const float center_color = tex2D<float>(image_texture, col, row);
 
   float color_sum = 0.0f;
   float color_squared_sum = 0.0f;
@@ -65,7 +64,7 @@ __global__ void FilterKernel(GpuMat<uint8_t> image, GpuMat<float> sum_image,
     for (int window_col = -window_radius; window_col <= window_radius;
          window_col += window_step) {
       const float color =
-          tex2D(image_texture, col + window_col, row + window_row);
+          tex2D<float>(image_texture, col + window_col, row + window_row);
       const float bilateral_weight = bilateral_weight_computer.Compute(
           window_row, window_col, center_color, color);
       color_sum += bilateral_weight * color;
@@ -95,24 +94,25 @@ void GpuMatRefImage::Filter(const uint8_t* image_data,
                             const size_t window_radius,
                             const size_t window_step, const float sigma_spatial,
                             const float sigma_color) {
-  CudaArrayWrapper<uint8_t> image_array(width_, height_, 1);
-  image_array.CopyToDevice(image_data);
-  image_texture.addressMode[0] = cudaAddressModeBorder;
-  image_texture.addressMode[1] = cudaAddressModeBorder;
-  image_texture.addressMode[2] = cudaAddressModeBorder;
-  image_texture.filterMode = cudaFilterModePoint;
-  image_texture.normalized = false;
+  cudaTextureDesc texture_desc;
+  memset(&texture_desc, 0, sizeof(texture_desc));
+  texture_desc.addressMode[0] = cudaAddressModeBorder;
+  texture_desc.addressMode[1] = cudaAddressModeBorder;
+  texture_desc.addressMode[2] = cudaAddressModeBorder;
+  texture_desc.filterMode = cudaFilterModePoint;
+  texture_desc.readMode = cudaReadModeNormalizedFloat;
+  texture_desc.normalizedCoords = false;
+  auto image_texture = CudaArrayLayeredTexture<uint8_t>::FromHostArray(
+      texture_desc, width_, height_, 1, image_data);
 
   const dim3 block_size(kBlockDimX, kBlockDimY);
   const dim3 grid_size((width_ - 1) / block_size.x + 1,
                        (height_ - 1) / block_size.y + 1);
 
-  CUDA_SAFE_CALL(cudaBindTextureToArray(image_texture, image_array.GetPtr()));
   FilterKernel<<<grid_size, block_size>>>(
-      *image, *sum_image, *squared_sum_image, window_radius, window_step,
-      sigma_spatial, sigma_color);
+      image_texture->GetObj(), *image, *sum_image, *squared_sum_image,
+      window_radius, window_step, sigma_spatial, sigma_color);
   CUDA_SYNC_AND_CHECK();
-  CUDA_SAFE_CALL(cudaUnbindTexture(image_texture));
 }
 
 }  // namespace mvs
diff --git a/src/mvs/gpu_mat_ref_image.h b/src/mvs/gpu_mat_ref_image.h
index 1e04e5f43..4f4be34e6 100644
--- a/src/mvs/gpu_mat_ref_image.h
+++ b/src/mvs/gpu_mat_ref_image.h
@@ -34,7 +34,7 @@
 
 #include <memory>
 
-#include "mvs/cuda_array_wrapper.h"
+#include "mvs/cuda_texture.h"
 #include "mvs/gpu_mat.h"
 
 namespace colmap {
@@ -64,8 +64,8 @@ class GpuMatRefImage {
   const static size_t kBlockDimX = 16;
   const static size_t kBlockDimY = 12;
 
-  size_t width_;
-  size_t height_;
+  const size_t width_;
+  const size_t height_;
 };
 
 struct BilateralWeightComputer {
diff --git a/src/mvs/patch_match_cuda.cu b/src/mvs/patch_match_cuda.cu
index 845fffa94..772f341a1 100644
--- a/src/mvs/patch_match_cuda.cu
+++ b/src/mvs/patch_match_cuda.cu
@@ -56,14 +56,6 @@
 namespace colmap {
 namespace mvs {
 
-texture<uint8_t, cudaTextureType2D, cudaReadModeNormalizedFloat>
-    ref_image_texture;
-texture<uint8_t, cudaTextureType2DLayered, cudaReadModeNormalizedFloat>
-    src_images_texture;
-texture<float, cudaTextureType2DLayered, cudaReadModeElementType>
-    src_depth_maps_texture;
-texture<float, cudaTextureType2D, cudaReadModeElementType> poses_texture;
-
 // Calibration of reference image as {fx, cx, fy, cy}.
 __constant__ float ref_K[4];
 // Calibration of reference image as {1/fx, -cx/fx, 1/fy, -cy/fy}.
@@ -229,18 +221,17 @@ __device__ inline float PropagateDepth(const float depth1,
 // First, compute triangulation angle between reference and source image for 3D
 // point. Second, compute incident angle between viewing direction of source
 // image and normal direction of 3D point. Both angles are cosine distances.
-__device__ inline void ComputeViewingAngles(const float point[3],
-                                            const float normal[3],
-                                            const int image_idx,
-                                            float* cos_triangulation_angle,
-                                            float* cos_incident_angle) {
+__device__ inline void ComputeViewingAngles(
+    const cudaTextureObject_t poses_texture, const float point[3],
+    const float normal[3], const int image_idx, float* cos_triangulation_angle,
+    float* cos_incident_angle) {
   *cos_triangulation_angle = 0.0f;
   *cos_incident_angle = 0.0f;
 
   // Projection center of source image.
   float C[3];
   for (int i = 0; i < 3; ++i) {
-    C[i] = tex2D(poses_texture, i + 16, image_idx);
+    C[i] = tex2D<float>(poses_texture, i + 16, image_idx);
   }
 
   // Ray from point to camera.
@@ -256,25 +247,25 @@ __device__ inline void ComputeViewingAngles(const float point[3],
   *cos_triangulation_angle = DotProduct3(SX, point) * RX_inv_norm * SX_inv_norm;
 }
 
-__device__ inline void ComposeHomography(const int image_idx, const int row,
-                                         const int col, const float depth,
-                                         const float normal[3], float H[9]) {
+__device__ inline void ComposeHomography(
+    const cudaTextureObject_t poses_texture, const int image_idx, const int row,
+    const int col, const float depth, const float normal[3], float H[9]) {
   // Calibration of source image.
   float K[4];
   for (int i = 0; i < 4; ++i) {
-    K[i] = tex2D(poses_texture, i, image_idx);
+    K[i] = tex2D<float>(poses_texture, i, image_idx);
   }
 
   // Relative rotation between reference and source image.
   float R[9];
   for (int i = 0; i < 9; ++i) {
-    R[i] = tex2D(poses_texture, i + 4, image_idx);
+    R[i] = tex2D<float>(poses_texture, i + 4, image_idx);
   }
 
   // Relative translation between reference and source image.
   float T[3];
   for (int i = 0; i < 3; ++i) {
-    T[i] = tex2D(poses_texture, i + 13, image_idx);
+    T[i] = tex2D<float>(poses_texture, i + 13, image_idx);
   }
 
   // Distance to the plane.
@@ -332,6 +323,9 @@ struct LocalRefImage {
   const static int kNumColumns = kThreadBlockSize * THREADS_PER_BLOCK;
   const static int kDataSize = kNumRows * kNumColumns;
 
+  __device__ explicit LocalRefImage(const cudaTextureObject_t ref_image_texture)
+      : ref_image_texture_(ref_image_texture) {}
+
   float* data = nullptr;
 
   __device__ inline void Read(const int row) {
@@ -357,7 +351,7 @@ struct LocalRefImage {
 #pragma unroll
         for (int block = 0; block < kThreadBlockSize; ++block) {
           data[local_row * kNumColumns + local_col] =
-              tex2D(ref_image_texture, global_col, global_row);
+              tex2D<float>(ref_image_texture_, global_col, global_row);
           local_col += THREADS_PER_BLOCK;
           global_col += THREADS_PER_BLOCK;
         }
@@ -382,12 +376,15 @@ struct LocalRefImage {
 #pragma unroll
       for (int block = 0; block < kThreadBlockSize; ++block) {
         data[local_row * kNumColumns + local_col] =
-            tex2D(ref_image_texture, global_col, global_row);
+            tex2D<float>(ref_image_texture_, global_col, global_row);
         local_col += THREADS_PER_BLOCK;
         global_col += THREADS_PER_BLOCK;
       }
     }
   }
+
+ private:
+  const cudaTextureObject_t ref_image_texture_;
 };
 
 // The return values is 1 - NCC, so the range is [0, 2], the smaller the
@@ -396,9 +393,15 @@ template <int kWindowSize, int kWindowStep>
 struct PhotoConsistencyCostComputer {
   const static int kWindowRadius = kWindowSize / 2;
 
-  __device__ PhotoConsistencyCostComputer(const float sigma_spatial,
-                                          const float sigma_color)
-      : bilateral_weight_computer_(sigma_spatial, sigma_color) {}
+  __device__ PhotoConsistencyCostComputer(
+      const cudaTextureObject_t ref_image_texture,
+      const cudaTextureObject_t src_images_texture,
+      const cudaTextureObject_t poses_texture, const float sigma_spatial,
+      const float sigma_color)
+      : local_ref_image(ref_image_texture),
+        src_images_texture_(src_images_texture),
+        poses_texture_(poses_texture),
+        bilateral_weight_computer_(sigma_spatial, sigma_color) {}
 
   // Maximum photo consistency cost as 1 - min(NCC).
   const float kMaxCost = 2.0f;
@@ -429,7 +432,8 @@ struct PhotoConsistencyCostComputer {
 
   __device__ inline float Compute() const {
     float tform[9];
-    ComposeHomography(src_image_idx, row, col, depth, normal, tform);
+    ComposeHomography(poses_texture_, src_image_idx, row, col, depth, normal,
+                      tform);
 
     float tform_step[8];
     for (int i = 0; i < 8; ++i) {
@@ -467,8 +471,8 @@ struct PhotoConsistencyCostComputer {
         const float norm_col_src = inv_z * col_src + 0.5f;
         const float norm_row_src = inv_z * row_src + 0.5f;
         const float ref_color = local_ref_image.data[ref_image_idx];
-        const float src_color = tex2DLayered(src_images_texture, norm_col_src,
-                                             norm_row_src, src_image_idx);
+        const float src_color = tex2DLayered<float>(
+            src_images_texture_, norm_col_src, norm_row_src, src_image_idx);
 
         const float bilateral_weight = bilateral_weight_computer_.Compute(
             row, col, ref_center_color, ref_color);
@@ -528,22 +532,24 @@ struct PhotoConsistencyCostComputer {
   }
 
  private:
+  const cudaTextureObject_t src_images_texture_;
+  const cudaTextureObject_t poses_texture_;
   const BilateralWeightComputer bilateral_weight_computer_;
 };
 
-__device__ inline float ComputeGeomConsistencyCost(const float row,
-                                                   const float col,
-                                                   const float depth,
-                                                   const int image_idx,
-                                                   const float max_cost) {
+__device__ inline float ComputeGeomConsistencyCost(
+    const cudaTextureObject_t poses_texture,
+    const cudaTextureObject_t src_depth_maps_texture, const float row,
+    const float col, const float depth, const int image_idx,
+    const float max_cost) {
   // Extract projection matrices for source image.
   float P[12];
   for (int i = 0; i < 12; ++i) {
-    P[i] = tex2D(poses_texture, i + 19, image_idx);
+    P[i] = tex2D<float>(poses_texture, i + 19, image_idx);
   }
   float inv_P[12];
   for (int i = 0; i < 12; ++i) {
-    inv_P[i] = tex2D(poses_texture, i + 31, image_idx);
+    inv_P[i] = tex2D<float>(poses_texture, i + 31, image_idx);
   }
 
   // Project point in reference image to world.
@@ -562,8 +568,8 @@ __device__ inline float ComputeGeomConsistencyCost(const float row,
                        P[6] * forward_point[2] + P[7]);
 
   // Extract depth in source image.
-  const float src_depth = tex2DLayered(src_depth_maps_texture, src_col + 0.5f,
-                                       src_row + 0.5f, image_idx);
+  const float src_depth = tex2DLayered<float>(
+      src_depth_maps_texture, src_col + 0.5f, src_row + 0.5f, image_idx);
 
   // Projection outside of source image.
   if (src_depth == 0.0f) {
@@ -794,15 +800,20 @@ template <int kWindowSize, int kWindowStep>
 __global__ void ComputeInitialCost(GpuMat<float> cost_map,
                                    const GpuMat<float> depth_map,
                                    const GpuMat<float> normal_map,
+                                   const cudaTextureObject_t ref_image_texture,
                                    const GpuMat<float> ref_sum_image,
                                    const GpuMat<float> ref_squared_sum_image,
+                                   const cudaTextureObject_t src_images_texture,
+                                   const cudaTextureObject_t poses_texture,
                                    const float sigma_spatial,
                                    const float sigma_color) {
   const int col = blockDim.x * blockIdx.x + threadIdx.x;
 
   typedef PhotoConsistencyCostComputer<kWindowSize, kWindowStep>
       PhotoConsistencyCostComputerType;
-  PhotoConsistencyCostComputerType pcc_computer(sigma_spatial, sigma_color);
+  PhotoConsistencyCostComputerType pcc_computer(
+      ref_image_texture, src_images_texture, poses_texture, sigma_spatial,
+      sigma_color);
   pcc_computer.col = col;
 
   __shared__ float local_ref_image_data
@@ -859,8 +870,13 @@ __global__ void SweepFromTopToBottom(
     GpuMat<float> global_workspace, GpuMat<curandState> rand_state_map,
     GpuMat<float> cost_map, GpuMat<float> depth_map, GpuMat<float> normal_map,
     GpuMat<uint8_t> consistency_mask, GpuMat<float> sel_prob_map,
-    const GpuMat<float> prev_sel_prob_map, const GpuMat<float> ref_sum_image,
-    const GpuMat<float> ref_squared_sum_image, const SweepOptions options) {
+    const GpuMat<float> prev_sel_prob_map,
+    const cudaTextureObject_t ref_image_texture,
+    const GpuMat<float> ref_sum_image,
+    const GpuMat<float> ref_squared_sum_image,
+    const cudaTextureObject_t src_images_texture,
+    const cudaTextureObject_t src_depth_maps_texture,
+    const cudaTextureObject_t poses_texture, const SweepOptions options) {
   const int col = blockDim.x * blockIdx.x + threadIdx.x;
 
   // Probability for boundary pixels.
@@ -904,8 +920,9 @@ __global__ void SweepFromTopToBottom(
 
   typedef PhotoConsistencyCostComputer<kWindowSize, kWindowStep>
       PhotoConsistencyCostComputerType;
-  PhotoConsistencyCostComputerType pcc_computer(options.sigma_spatial,
-                                                options.sigma_color);
+  PhotoConsistencyCostComputerType pcc_computer(
+      ref_image_texture, src_images_texture, poses_texture,
+      options.sigma_spatial, options.sigma_color);
   pcc_computer.col = col;
 
   __shared__ float local_ref_image_data
@@ -982,16 +999,17 @@ __global__ void SweepFromTopToBottom(
 
       float cos_triangulation_angle;
       float cos_incident_angle;
-      ComputeViewingAngles(point, curr_param_state.normal, image_idx,
-                           &cos_triangulation_angle, &cos_incident_angle);
+      ComputeViewingAngles(poses_texture, point, curr_param_state.normal,
+                           image_idx, &cos_triangulation_angle,
+                           &cos_incident_angle);
       const float tri_prob =
           likelihood_computer.ComputeTriProb(cos_triangulation_angle);
       const float inc_prob =
           likelihood_computer.ComputeIncProb(cos_incident_angle);
 
       float H[9];
-      ComposeHomography(image_idx, row, col, curr_param_state.depth,
-                        curr_param_state.normal, H);
+      ComposeHomography(poses_texture, image_idx, row, col,
+                        curr_param_state.depth, curr_param_state.normal, H);
       const float res_prob =
           likelihood_computer.ComputeResolutionProb<kWindowSize>(H, row, col);
 
@@ -1035,10 +1053,11 @@ __global__ void SweepFromTopToBottom(
 
       costs[0] += cost_map.Get(row, col, pcc_computer.src_image_idx);
       if (kGeomConsistencyTerm) {
-        costs[0] += options.geom_consistency_regularizer *
-                    ComputeGeomConsistencyCost(
-                        row, col, depths[0], pcc_computer.src_image_idx,
-                        options.geom_consistency_max_cost);
+        costs[0] +=
+            options.geom_consistency_regularizer *
+            ComputeGeomConsistencyCost(
+                poses_texture, src_depth_maps_texture, row, col, depths[0],
+                pcc_computer.src_image_idx, options.geom_consistency_max_cost);
       }
 
       for (int i = 1; i < kNumCosts; ++i) {
@@ -1048,7 +1067,8 @@ __global__ void SweepFromTopToBottom(
         if (kGeomConsistencyTerm) {
           costs[i] += options.geom_consistency_regularizer *
                       ComputeGeomConsistencyCost(
-                          row, col, depths[i], pcc_computer.src_image_idx,
+                          poses_texture, src_depth_maps_texture, row, col,
+                          depths[i], pcc_computer.src_image_idx,
                           options.geom_consistency_max_cost);
         }
       }
@@ -1102,7 +1122,7 @@ __global__ void SweepFromTopToBottom(
       for (int image_idx = 0; image_idx < cost_map.GetDepth(); ++image_idx) {
         float cos_triangulation_angle;
         float cos_incident_angle;
-        ComputeViewingAngles(best_point, best_normal, image_idx,
+        ComputeViewingAngles(poses_texture, best_point, best_normal, image_idx,
                              &cos_triangulation_angle, &cos_incident_angle);
         if (cos_triangulation_angle > cos_min_triangulation_angle ||
             cos_incident_angle <= 0.0f) {
@@ -1115,7 +1135,8 @@ __global__ void SweepFromTopToBottom(
             num_consistent += 1;
           }
         } else if (!kFilterPhotoConsistency) {
-          if (ComputeGeomConsistencyCost(row, col, best_depth, image_idx,
+          if (ComputeGeomConsistencyCost(poses_texture, src_depth_maps_texture,
+                                         row, col, best_depth, image_idx,
                                          options.geom_consistency_max_cost) <=
               options.filter_geom_consistency_max_cost) {
             consistency_mask.Set(row, col, image_idx, 1);
@@ -1123,7 +1144,8 @@ __global__ void SweepFromTopToBottom(
           }
         } else {
           if (sel_prob_map.Get(row, col, image_idx) >= min_ncc_prob &&
-              ComputeGeomConsistencyCost(row, col, best_depth, image_idx,
+              ComputeGeomConsistencyCost(poses_texture, src_depth_maps_texture,
+                                         row, col, best_depth, image_idx,
                                          options.geom_consistency_max_cost) <=
                   options.filter_geom_consistency_max_cost) {
             consistency_mask.Set(row, col, image_idx, 1);
@@ -1169,53 +1191,49 @@ PatchMatchCuda::PatchMatchCuda(const PatchMatchOptions& options,
   InitWorkspaceMemory();
 }
 
-PatchMatchCuda::~PatchMatchCuda() {
-  for (size_t i = 0; i < 4; ++i) {
-    poses_device_[i].reset();
-  }
-}
-
 void PatchMatchCuda::Run() {
 #define CASE_WINDOW_RADIUS(window_radius, window_step)              \
   case window_radius:                                               \
     RunWithWindowSizeAndStep<2 * window_radius + 1, window_step>(); \
     break;
 
-#define CASE_WINDOW_STEP(window_step)                                 \
-  case window_step:                                                   \
-    switch (options_.window_radius) {                                 \
-      CASE_WINDOW_RADIUS(1, window_step)                              \
-      CASE_WINDOW_RADIUS(2, window_step)                              \
-      CASE_WINDOW_RADIUS(3, window_step)                              \
-      CASE_WINDOW_RADIUS(4, window_step)                              \
-      CASE_WINDOW_RADIUS(5, window_step)                              \
-      CASE_WINDOW_RADIUS(6, window_step)                              \
-      CASE_WINDOW_RADIUS(7, window_step)                              \
-      CASE_WINDOW_RADIUS(8, window_step)                              \
-      CASE_WINDOW_RADIUS(9, window_step)                              \
-      CASE_WINDOW_RADIUS(10, window_step)                             \
-      CASE_WINDOW_RADIUS(11, window_step)                             \
-      CASE_WINDOW_RADIUS(12, window_step)                             \
-      CASE_WINDOW_RADIUS(13, window_step)                             \
-      CASE_WINDOW_RADIUS(14, window_step)                             \
-      CASE_WINDOW_RADIUS(15, window_step)                             \
-      CASE_WINDOW_RADIUS(16, window_step)                             \
-      CASE_WINDOW_RADIUS(17, window_step)                             \
-      CASE_WINDOW_RADIUS(18, window_step)                             \
-      CASE_WINDOW_RADIUS(19, window_step)                             \
-      CASE_WINDOW_RADIUS(20, window_step)                             \
-      default: {                                                      \
-        std::cerr << "Error: Window size not supported" << std::endl; \
-        break;                                                        \
-      }                                                               \
-    }                                                                 \
+#define CASE_WINDOW_STEP(window_step)                                \
+  case window_step:                                                  \
+    switch (options_.window_radius) {                                \
+      CASE_WINDOW_RADIUS(1, window_step)                             \
+      CASE_WINDOW_RADIUS(2, window_step)                             \
+      CASE_WINDOW_RADIUS(3, window_step)                             \
+      CASE_WINDOW_RADIUS(4, window_step)                             \
+      CASE_WINDOW_RADIUS(5, window_step)                             \
+      CASE_WINDOW_RADIUS(6, window_step)                             \
+      CASE_WINDOW_RADIUS(7, window_step)                             \
+      CASE_WINDOW_RADIUS(8, window_step)                             \
+      CASE_WINDOW_RADIUS(9, window_step)                             \
+      CASE_WINDOW_RADIUS(10, window_step)                            \
+      CASE_WINDOW_RADIUS(11, window_step)                            \
+      CASE_WINDOW_RADIUS(12, window_step)                            \
+      CASE_WINDOW_RADIUS(13, window_step)                            \
+      CASE_WINDOW_RADIUS(14, window_step)                            \
+      CASE_WINDOW_RADIUS(15, window_step)                            \
+      CASE_WINDOW_RADIUS(16, window_step)                            \
+      CASE_WINDOW_RADIUS(17, window_step)                            \
+      CASE_WINDOW_RADIUS(18, window_step)                            \
+      CASE_WINDOW_RADIUS(19, window_step)                            \
+      CASE_WINDOW_RADIUS(20, window_step)                            \
+      default: {                                                     \
+        std::cerr << "Error: Window size " << options_.window_radius \
+                  << " not supported" << std::endl;                  \
+        break;                                                       \
+      }                                                              \
+    }                                                                \
     break;
 
   switch (options_.window_step) {
     CASE_WINDOW_STEP(1)
     CASE_WINDOW_STEP(2)
     default: {
-      std::cerr << "Error: Window step not supported" << std::endl;
+      std::cerr << "Error: Window step " << options_.window_step
+                << " not supported" << std::endl;
       break;
     }
   }
@@ -1274,9 +1292,10 @@ void PatchMatchCuda::RunWithWindowSizeAndStep() {
   ComputeCudaConfig();
   ComputeInitialCost<kWindowSize, kWindowStep>
       <<<sweep_grid_size_, sweep_block_size_>>>(
-          *cost_map_, *depth_map_, *normal_map_, *ref_image_->sum_image,
-          *ref_image_->squared_sum_image, options_.sigma_spatial,
-          options_.sigma_color);
+          *cost_map_, *depth_map_, *normal_map_, ref_image_texture_->GetObj(),
+          *ref_image_->sum_image, *ref_image_->squared_sum_image,
+          src_images_texture_->GetObj(), poses_texture_[0]->GetObj(),
+          options_.sigma_spatial, options_.sigma_color);
   CUDA_SYNC_AND_CHECK();
 
   init_timer.Print("Initialization");
@@ -1324,8 +1343,13 @@ void PatchMatchCuda::RunWithWindowSizeAndStep() {
       <<<sweep_grid_size_, sweep_block_size_>>>(                         \
           *global_workspace_, *rand_state_map_, *cost_map_, *depth_map_, \
           *normal_map_, *consistency_mask_, *sel_prob_map_,              \
-          *prev_sel_prob_map_, *ref_image_->sum_image,                   \
-          *ref_image_->squared_sum_image, sweep_options);
+          *prev_sel_prob_map_, ref_image_texture_->GetObj(),             \
+          *ref_image_->sum_image, *ref_image_->squared_sum_image,        \
+          src_images_texture_->GetObj(),                                 \
+          src_depth_maps_texture_ == nullptr                             \
+              ? 0                                                        \
+              : src_depth_maps_texture_->GetObj(),                       \
+          poses_texture_[rotation_in_half_pi_]->GetObj(), sweep_options);
 
       if (last_sweep) {
         if (options_.filter) {
@@ -1410,13 +1434,26 @@ void PatchMatchCuda::ComputeCudaConfig() {
   elem_wise_grid_size_.z = 1;
 }
 
+void PatchMatchCuda::BindRefImageTexture() {
+  cudaTextureDesc texture_desc;
+  memset(&texture_desc, 0, sizeof(texture_desc));
+  texture_desc.addressMode[0] = cudaAddressModeBorder;
+  texture_desc.addressMode[1] = cudaAddressModeBorder;
+  texture_desc.addressMode[2] = cudaAddressModeBorder;
+  texture_desc.filterMode = cudaFilterModePoint;
+  texture_desc.readMode = cudaReadModeNormalizedFloat;
+  texture_desc.normalizedCoords = false;
+  ref_image_texture_ = CudaArrayLayeredTexture<uint8_t>::FromGpuMat(
+      texture_desc, *ref_image_->image);
+}
+
 void PatchMatchCuda::InitRefImage() {
   const Image& ref_image = problem_.images->at(problem_.ref_image_idx);
 
   ref_width_ = ref_image.GetWidth();
   ref_height_ = ref_image.GetHeight();
 
-  // Upload to device.
+  // Upload to device and filter.
   ref_image_.reset(new GpuMatRefImage(ref_width_, ref_height_));
   const std::vector<uint8_t> ref_image_array =
       ref_image.GetBitmap().ConvertToRowMajorArray();
@@ -1424,18 +1461,7 @@ void PatchMatchCuda::InitRefImage() {
                      options_.window_step, options_.sigma_spatial,
                      options_.sigma_color);
 
-  ref_image_device_.reset(
-      new CudaArrayWrapper<uint8_t>(ref_width_, ref_height_, 1));
-  ref_image_device_->CopyFromGpuMat(*ref_image_->image);
-
-  // Create texture.
-  ref_image_texture.addressMode[0] = cudaAddressModeBorder;
-  ref_image_texture.addressMode[1] = cudaAddressModeBorder;
-  ref_image_texture.addressMode[2] = cudaAddressModeBorder;
-  ref_image_texture.filterMode = cudaFilterModePoint;
-  ref_image_texture.normalized = false;
-  CUDA_SAFE_CALL(
-      cudaBindTextureToArray(ref_image_texture, ref_image_device_->GetPtr()));
+  BindRefImageTexture();
 }
 
 void PatchMatchCuda::InitSourceImages() {
@@ -1470,19 +1496,18 @@ void PatchMatchCuda::InitSourceImages() {
       }
     }
 
-    // Upload to device.
-    src_images_device_.reset(new CudaArrayWrapper<uint8_t>(
-        max_width, max_height, problem_.src_image_idxs.size()));
-    src_images_device_->CopyToDevice(src_images_host_data.data());
-
     // Create source images texture.
-    src_images_texture.addressMode[0] = cudaAddressModeBorder;
-    src_images_texture.addressMode[1] = cudaAddressModeBorder;
-    src_images_texture.addressMode[2] = cudaAddressModeBorder;
-    src_images_texture.filterMode = cudaFilterModeLinear;
-    src_images_texture.normalized = false;
-    CUDA_SAFE_CALL(cudaBindTextureToArray(src_images_texture,
-                                          src_images_device_->GetPtr()));
+    cudaTextureDesc texture_desc;
+    memset(&texture_desc, 0, sizeof(texture_desc));
+    texture_desc.addressMode[0] = cudaAddressModeBorder;
+    texture_desc.addressMode[1] = cudaAddressModeBorder;
+    texture_desc.addressMode[2] = cudaAddressModeBorder;
+    texture_desc.filterMode = cudaFilterModeLinear;
+    texture_desc.readMode = cudaReadModeNormalizedFloat;
+    texture_desc.normalizedCoords = false;
+    src_images_texture_ = CudaArrayLayeredTexture<uint8_t>::FromHostArray(
+        texture_desc, max_width, max_height, problem_.src_image_idxs.size(),
+        src_images_host_data.data());
   }
 
   // Upload source depth maps to device.
@@ -1504,19 +1529,18 @@ void PatchMatchCuda::InitSourceImages() {
       }
     }
 
-    src_depth_maps_device_.reset(new CudaArrayWrapper<float>(
-        max_width, max_height, problem_.src_image_idxs.size()));
-    src_depth_maps_device_->CopyToDevice(src_depth_maps_host_data.data());
-
     // Create source depth maps texture.
-    src_depth_maps_texture.addressMode[0] = cudaAddressModeBorder;
-    src_depth_maps_texture.addressMode[1] = cudaAddressModeBorder;
-    src_depth_maps_texture.addressMode[2] = cudaAddressModeBorder;
-    // TODO: Check if linear interpolation improves results or not.
-    src_depth_maps_texture.filterMode = cudaFilterModePoint;
-    src_depth_maps_texture.normalized = false;
-    CUDA_SAFE_CALL(cudaBindTextureToArray(src_depth_maps_texture,
-                                          src_depth_maps_device_->GetPtr()));
+    cudaTextureDesc texture_desc;
+    memset(&texture_desc, 0, sizeof(texture_desc));
+    texture_desc.addressMode[0] = cudaAddressModeBorder;
+    texture_desc.addressMode[1] = cudaAddressModeBorder;
+    texture_desc.addressMode[2] = cudaAddressModeBorder;
+    texture_desc.filterMode = cudaFilterModePoint;
+    texture_desc.readMode = cudaReadModeElementType;
+    texture_desc.normalizedCoords = false;
+    src_depth_maps_texture_ = CudaArrayLayeredTexture<float>::FromHostArray(
+        texture_desc, max_width, max_height, problem_.src_image_idxs.size(),
+        src_depth_maps_host_data.data());
   }
 }
 
@@ -1576,6 +1600,15 @@ void PatchMatchCuda::InitTransforms() {
   // Matrix for 90deg rotation around Z-axis in counter-clockwise direction.
   const float R_z90[9] = {0, 1, 0, -1, 0, 0, 0, 0, 1};
 
+  cudaTextureDesc texture_desc;
+  memset(&texture_desc, 0, sizeof(texture_desc));
+  texture_desc.addressMode[0] = cudaAddressModeBorder;
+  texture_desc.addressMode[1] = cudaAddressModeBorder;
+  texture_desc.addressMode[2] = cudaAddressModeBorder;
+  texture_desc.filterMode = cudaFilterModePoint;
+  texture_desc.readMode = cudaReadModeElementType;
+  texture_desc.normalizedCoords = false;
+
   for (size_t i = 0; i < 4; ++i) {
     const size_t kNumTformParams = 4 + 9 + 3 + 3 + 12 + 12;
     std::vector<float> poses_host_data(kNumTformParams *
@@ -1614,20 +1647,12 @@ void PatchMatchCuda::InitTransforms() {
       offset += 12;
     }
 
-    poses_device_[i].reset(new CudaArrayWrapper<float>(
-        kNumTformParams, problem_.src_image_idxs.size(), 1));
-    poses_device_[i]->CopyToDevice(poses_host_data.data());
+    poses_texture_[i] = CudaArrayLayeredTexture<float>::FromHostArray(
+        texture_desc, kNumTformParams, problem_.src_image_idxs.size(), 1,
+        poses_host_data.data());
 
     RotatePose(R_z90, rotated_R, rotated_T);
   }
-
-  poses_texture.addressMode[0] = cudaAddressModeBorder;
-  poses_texture.addressMode[1] = cudaAddressModeBorder;
-  poses_texture.addressMode[2] = cudaAddressModeBorder;
-  poses_texture.filterMode = cudaFilterModePoint;
-  poses_texture.normalized = false;
-  CUDA_SAFE_CALL(
-      cudaBindTextureToArray(poses_texture, poses_device_[0]->GetPtr()));
 }
 
 void PatchMatchCuda::InitWorkspaceMemory() {
@@ -1727,15 +1752,9 @@ void PatchMatchCuda::Rotate() {
     ref_image_->squared_sum_image->Rotate(
         rotated_ref_image->squared_sum_image.get());
     ref_image_.swap(rotated_ref_image);
+    BindRefImageTexture();
   }
 
-  // Bind rotated reference image to texture.
-  ref_image_device_.reset(new CudaArrayWrapper<uint8_t>(width, height, 1));
-  ref_image_device_->CopyFromGpuMat(*ref_image_->image);
-  CUDA_SAFE_CALL(cudaUnbindTexture(ref_image_texture));
-  CUDA_SAFE_CALL(
-      cudaBindTextureToArray(ref_image_texture, ref_image_device_->GetPtr()));
-
   // Rotate selection probability map.
   prev_sel_prob_map_.reset(
       new GpuMat<float>(width, height, problem_.src_image_idxs.size()));
@@ -1751,11 +1770,6 @@ void PatchMatchCuda::Rotate() {
     cost_map_.swap(rotated_cost_map);
   }
 
-  // Rotate transformations.
-  CUDA_SAFE_CALL(cudaUnbindTexture(poses_texture));
-  CUDA_SAFE_CALL(cudaBindTextureToArray(
-      poses_texture, poses_device_[rotation_in_half_pi_]->GetPtr()));
-
   // Rotate calibration.
   CUDA_SAFE_CALL(cudaMemcpyToSymbol(ref_K, ref_K_host_[rotation_in_half_pi_],
                                     sizeof(float) * 4, 0,
diff --git a/src/mvs/patch_match_cuda.h b/src/mvs/patch_match_cuda.h
index adbecdbd9..9e85e9b32 100644
--- a/src/mvs/patch_match_cuda.h
+++ b/src/mvs/patch_match_cuda.h
@@ -38,7 +38,7 @@
 
 #include <cuda_runtime.h>
 
-#include "mvs/cuda_array_wrapper.h"
+#include "mvs/cuda_texture.h"
 #include "mvs/depth_map.h"
 #include "mvs/gpu_mat.h"
 #include "mvs/gpu_mat_prng.h"
@@ -54,7 +54,6 @@ class PatchMatchCuda {
  public:
   PatchMatchCuda(const PatchMatchOptions& options,
                  const PatchMatch::Problem& problem);
-  ~PatchMatchCuda();
 
   void Run();
 
@@ -69,6 +68,8 @@ class PatchMatchCuda {
 
   void ComputeCudaConfig();
 
+  void BindRefImageTexture();
+
   void InitRefImage();
   void InitSourceImages();
   void InitTransforms();
@@ -96,9 +97,9 @@ class PatchMatchCuda {
   int rotation_in_half_pi_;
 
   // Reference and source image input data.
-  std::unique_ptr<CudaArrayWrapper<uint8_t>> ref_image_device_;
-  std::unique_ptr<CudaArrayWrapper<uint8_t>> src_images_device_;
-  std::unique_ptr<CudaArrayWrapper<float>> src_depth_maps_device_;
+  std::unique_ptr<CudaArrayLayeredTexture<uint8_t>> ref_image_texture_;
+  std::unique_ptr<CudaArrayLayeredTexture<uint8_t>> src_images_texture_;
+  std::unique_ptr<CudaArrayLayeredTexture<float>> src_depth_maps_texture_;
 
   // Relative poses from rotated versions of reference image to source images
   // corresponding to _rotationInHalfPi:
@@ -114,7 +115,7 @@ class PatchMatchCuda {
   // R, T, C, P, P^-1 denote the relative rotation, translation, camera
   // center, projection, and inverse projection from there reference to the
   // i-th source image.
-  std::unique_ptr<CudaArrayWrapper<float>> poses_device_[4];
+  std::unique_ptr<CudaArrayLayeredTexture<float>> poses_texture_[4];
 
   // Calibration matrix for rotated versions of reference image
   // as {K[0, 0], K[0, 2], K[1, 1], K[1, 2]} corresponding to _rotationInHalfPi.
